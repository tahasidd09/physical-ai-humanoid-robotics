"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[822],{7410:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"module2/week6-gazebo","title":"Robot Simulation with Gazebo","description":"Physics simulation, URDF/SDF formats, and building digital twins for humanoid robots","source":"@site/docs/module2/week6-gazebo.md","sourceDirName":"module2","slug":"/module2/week6-gazebo","permalink":"/physical-ai-and-humanoid-robotics/docs/module2/week6-gazebo","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"Robot Simulation with Gazebo","description":"Physics simulation, URDF/SDF formats, and building digital twins for humanoid robots","keywords":["gazebo","simulation","urdf","sdf","physics","digital-twin"]},"sidebar":"tutorialSidebar","previous":{"title":"Module 2: Gazebo & Unity","permalink":"/physical-ai-and-humanoid-robotics/docs/category/module-2-gazebo--unity"},"next":{"title":"Unity Integration and Sensor Simulation","permalink":"/physical-ai-and-humanoid-robotics/docs/module2/week7-gazebo-unity"}}');var t=i(4848),o=i(8453);const l={sidebar_position:1,title:"Robot Simulation with Gazebo",description:"Physics simulation, URDF/SDF formats, and building digital twins for humanoid robots",keywords:["gazebo","simulation","urdf","sdf","physics","digital-twin"]},r="Week 6: Robot Simulation with Gazebo",a={},d=[{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"The Physics (Why)",id:"the-physics-why",level:2},{value:"The Analogy (Mental Model)",id:"the-analogy-mental-model",level:2},{value:"The Visualization (Simulation Architecture)",id:"the-visualization-simulation-architecture",level:2},{value:"The Code (Implementation)",id:"the-code-implementation",level:2},{value:"Installation (Ubuntu 22.04)",id:"installation-ubuntu-2204",level:3},{value:"URDF Robot Description",id:"urdf-robot-description",level:3},{value:"SDF World File",id:"sdf-world-file",level:3},{value:"ROS 2 Gazebo Bridge",id:"ros-2-gazebo-bridge",level:3},{value:"The Hardware Reality (Warning)",id:"the-hardware-reality-warning",level:2},{value:"URDF vs SDF Comparison",id:"urdf-vs-sdf-comparison",level:3},{value:"Assessment",id:"assessment",level:2},{value:"Recall",id:"recall",level:3},{value:"Apply",id:"apply",level:3},{value:"Analyze",id:"analyze",level:3}];function c(n){const e={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"week-6-robot-simulation-with-gazebo",children:"Week 6: Robot Simulation with Gazebo"})}),"\n",(0,t.jsx)(e.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,t.jsx)(e.p,{children:"By the end of this chapter, you should be able to:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Set up and configure the Gazebo simulation environment"}),"\n",(0,t.jsx)(e.li,{children:"Understand URDF and SDF robot description formats"}),"\n",(0,t.jsx)(e.li,{children:"Simulate physics, gravity, and collisions accurately"}),"\n",(0,t.jsx)(e.li,{children:"Create custom simulation worlds for humanoid testing"}),"\n",(0,t.jsx)(e.li,{children:"Bridge Gazebo with ROS 2 for robot control"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"the-physics-why",children:"The Physics (Why)"}),"\n",(0,t.jsx)(e.p,{children:"Before deploying a humanoid robot in the real world, you need a safe environment to test algorithms. Real robots are expensive ($10k-$100k+), can be damaged by falls, and pose safety risks during development."}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Digital twins"})," solve this by creating virtual replicas of physical robots. In simulation, you can:"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Test walking algorithms without risking hardware damage"}),"\n",(0,t.jsx)(e.li,{children:"Simulate dangerous scenarios (falling, collisions) safely"}),"\n",(0,t.jsx)(e.li,{children:"Iterate rapidly on control algorithms"}),"\n",(0,t.jsx)(e.li,{children:"Generate unlimited training data for AI models"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"Gazebo provides accurate physics simulation including gravity, friction, collision detection, and sensor modeling\u2014essential for developing robust robotic systems."}),"\n",(0,t.jsx)(e.h2,{id:"the-analogy-mental-model",children:"The Analogy (Mental Model)"}),"\n",(0,t.jsxs)(e.p,{children:["Think of ",(0,t.jsx)(e.strong,{children:"Gazebo as a physics laboratory"})," where you can experiment with robots under controlled conditions. Just as aerospace engineers use wind tunnels to test aircraft before flight, roboticists use Gazebo to test robots before real-world deployment."]}),"\n",(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:"Environment"}),(0,t.jsx)(e.th,{children:"Purpose"}),(0,t.jsx)(e.th,{children:"Fidelity"}),(0,t.jsx)(e.th,{children:"Speed"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Gazebo"})}),(0,t.jsx)(e.td,{children:"Physics accuracy"}),(0,t.jsx)(e.td,{children:"High"}),(0,t.jsx)(e.td,{children:"Medium"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Unity"})}),(0,t.jsx)(e.td,{children:"Visual fidelity"}),(0,t.jsx)(e.td,{children:"Very High"}),(0,t.jsx)(e.td,{children:"Fast"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Real World"})}),(0,t.jsx)(e.td,{children:"Ground truth"}),(0,t.jsx)(e.td,{children:"Perfect"}),(0,t.jsx)(e.td,{children:"Real-time"})]})]})]}),"\n",(0,t.jsx)(e.h2,{id:"the-visualization-simulation-architecture",children:"The Visualization (Simulation Architecture)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-mermaid",children:'graph TB\n    subgraph "Gazebo Simulation"\n        A[World SDF] --\x3e B[Physics Engine]\n        C[Robot URDF/SDF] --\x3e B\n        B --\x3e D[Collision Detection]\n        B --\x3e E[Dynamics Solver]\n        D --\x3e F[Contact Forces]\n        E --\x3e G[Joint States]\n    end\n    \n    subgraph "ROS 2 Bridge"\n        F --\x3e H[/contact_sensor]\n        G --\x3e I[/joint_states]\n        J[/cmd_vel] --\x3e B\n    end\n    \n    subgraph "Control Nodes"\n        I --\x3e K[State Estimator]\n        K --\x3e L[Controller]\n        L --\x3e J\n    end\n'})}),"\n",(0,t.jsx)(e.h2,{id:"the-code-implementation",children:"The Code (Implementation)"}),"\n",(0,t.jsx)(e.h3,{id:"installation-ubuntu-2204",children:"Installation (Ubuntu 22.04)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"# Install Gazebo Harmonic (recommended for ROS 2 Humble)\nsudo apt-get update\nsudo apt-get install ros-humble-ros-gz\n\n# Verify installation\ngz sim --version\n\n# Launch an empty world\ngz sim empty.sdf\n"})}),"\n",(0,t.jsx)(e.h3,{id:"urdf-robot-description",children:"URDF Robot Description"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n\x3c!-- humanoid_leg.urdf - Simple humanoid leg for simulation --\x3e\n<robot name="humanoid_leg">\n  \n  \x3c!-- Base link (hip) --\x3e\n  <link name="hip_link">\n    <visual>\n      <geometry>\n        <box size="0.1 0.1 0.05"/>\n      </geometry>\n      <material name="gray">\n        <color rgba="0.5 0.5 0.5 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.1 0.1 0.05"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="2.0"/>\n      <inertia ixx="0.01" ixy="0" ixz="0" \n               iyy="0.01" iyz="0" izz="0.01"/>\n    </inertial>\n  </link>\n  \n  \x3c!-- Thigh link --\x3e\n  <link name="thigh_link">\n    <visual>\n      <origin xyz="0 0 -0.2"/>\n      <geometry>\n        <cylinder radius="0.04" length="0.4"/>\n      </geometry>\n    </visual>\n    <collision>\n      <origin xyz="0 0 -0.2"/>\n      <geometry>\n        <cylinder radius="0.04" length="0.4"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <origin xyz="0 0 -0.2"/>\n      <mass value="3.0"/>\n      <inertia ixx="0.05" ixy="0" ixz="0" \n               iyy="0.05" iyz="0" izz="0.01"/>\n    </inertial>\n  </link>\n  \n  \x3c!-- Hip joint --\x3e\n  <joint name="hip_pitch" type="revolute">\n    <parent link="hip_link"/>\n    <child link="thigh_link"/>\n    <origin xyz="0 0 -0.025"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="-1.57" upper="1.57" effort="100" velocity="5"/>\n    <dynamics damping="0.1" friction="0.05"/>\n  </joint>\n  \n  \x3c!-- Shin link --\x3e\n  <link name="shin_link">\n    <visual>\n      <origin xyz="0 0 -0.2"/>\n      <geometry>\n        <cylinder radius="0.03" length="0.4"/>\n      </geometry>\n    </visual>\n    <collision>\n      <origin xyz="0 0 -0.2"/>\n      <geometry>\n        <cylinder radius="0.03" length="0.4"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <origin xyz="0 0 -0.2"/>\n      <mass value="2.0"/>\n      <inertia ixx="0.03" ixy="0" ixz="0" \n               iyy="0.03" iyz="0" izz="0.005"/>\n    </inertial>\n  </link>\n  \n  \x3c!-- Knee joint --\x3e\n  <joint name="knee_pitch" type="revolute">\n    <parent link="thigh_link"/>\n    <child link="shin_link"/>\n    <origin xyz="0 0 -0.4"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="0" upper="2.5" effort="80" velocity="5"/>\n    <dynamics damping="0.1" friction="0.05"/>\n  </joint>\n\n</robot>\n'})}),"\n",(0,t.jsx)(e.h3,{id:"sdf-world-file",children:"SDF World File"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n\x3c!-- humanoid_world.sdf - Test environment for humanoid robots --\x3e\n<sdf version="1.8">\n  <world name="humanoid_test">\n    \n    \x3c!-- Physics configuration --\x3e\n    <physics type="ode">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n      <real_time_update_rate>1000</real_time_update_rate>\n      <ode>\n        <solver>\n          <type>quick</type>\n          <iters>50</iters>\n        </solver>\n      </ode>\n    </physics>\n    \n    \x3c!-- Lighting --\x3e\n    <light type="directional" name="sun">\n      <cast_shadows>true</cast_shadows>\n      <pose>0 0 10 0 0 0</pose>\n      <diffuse>0.8 0.8 0.8 1</diffuse>\n    </light>\n    \n    \x3c!-- Ground plane --\x3e\n    <model name="ground">\n      <static>true</static>\n      <link name="ground_link">\n        <collision name="collision">\n          <geometry>\n            <plane>\n              <normal>0 0 1</normal>\n              <size>100 100</size>\n            </plane>\n          </geometry>\n          <surface>\n            <friction>\n              <ode>\n                <mu>0.8</mu>\n                <mu2>0.8</mu2>\n              </ode>\n            </friction>\n          </surface>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <plane>\n              <normal>0 0 1</normal>\n              <size>100 100</size>\n            </plane>\n          </geometry>\n        </visual>\n      </link>\n    </model>\n    \n    \x3c!-- Obstacles for testing --\x3e\n    <model name="obstacle_box">\n      <pose>2 0 0.25 0 0 0</pose>\n      <static>true</static>\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <box><size>0.5 0.5 0.5</size></box>\n          </geometry>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <box><size>0.5 0.5 0.5</size></box>\n          </geometry>\n          <material>\n            <ambient>1 0 0 1</ambient>\n          </material>\n        </visual>\n      </link>\n    </model>\n    \n  </world>\n</sdf>\n'})}),"\n",(0,t.jsx)(e.h3,{id:"ros-2-gazebo-bridge",children:"ROS 2 Gazebo Bridge"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""\ngazebo_bridge.py - Bridge between Gazebo and ROS 2.\n"""\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import Float64MultiArray\n\n\nclass GazeboBridge(Node):\n    """Bridges Gazebo simulation with ROS 2 control."""\n    \n    def __init__(self):\n        super().__init__(\'gazebo_bridge\')\n        \n        # Subscribe to joint states from Gazebo\n        self.joint_sub = self.create_subscription(\n            JointState,\n            \'/joint_states\',\n            self.joint_callback,\n            10\n        )\n        \n        # Publish joint commands to Gazebo\n        self.cmd_pub = self.create_publisher(\n            Float64MultiArray,\n            \'/joint_commands\',\n            10\n        )\n        \n        self.get_logger().info(\'Gazebo bridge started\')\n    \n    def joint_callback(self, msg: JointState):\n        """Process joint states from simulation."""\n        for name, pos, vel in zip(msg.name, msg.position, msg.velocity):\n            self.get_logger().debug(f\'{name}: pos={pos:.3f}, vel={vel:.3f}\')\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = GazeboBridge()\n    rclpy.spin(node)\n    node.destroy_node()\n    rclpy.shutdown()\n\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,t.jsx)(e.h2,{id:"the-hardware-reality-warning",children:"The Hardware Reality (Warning)"}),"\n",(0,t.jsxs)(e.admonition,{title:"The Reality Gap",type:"danger",children:[(0,t.jsx)(e.p,{children:"Simulation is never perfect. Common issues when moving from Gazebo to real robots:"}),(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Friction"}),": Simulated friction rarely matches real surfaces"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Motor dynamics"}),": Real motors have delays and nonlinearities"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Sensor noise"}),": Real sensors are noisier than simulated ones"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Contact modeling"}),": Soft contacts are hard to simulate accurately"]}),"\n"]})]}),"\n",(0,t.jsxs)(e.admonition,{title:"Performance Requirements",type:"warning",children:[(0,t.jsx)(e.p,{children:"Gazebo with complex humanoid models requires significant compute:"}),(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"CPU"}),": Physics runs on CPU, needs fast single-thread performance"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"GPU"}),": Only needed for camera/LiDAR rendering"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"RAM"}),": 16GB minimum, 32GB recommended for complex scenes"]}),"\n"]})]}),"\n",(0,t.jsx)(e.h3,{id:"urdf-vs-sdf-comparison",children:"URDF vs SDF Comparison"}),"\n",(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:"Feature"}),(0,t.jsx)(e.th,{children:"URDF"}),(0,t.jsx)(e.th,{children:"SDF"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Purpose"})}),(0,t.jsx)(e.td,{children:"Robot description"}),(0,t.jsx)(e.td,{children:"World + Robot"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Physics"})}),(0,t.jsx)(e.td,{children:"Basic"}),(0,t.jsx)(e.td,{children:"Advanced"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Sensors"})}),(0,t.jsx)(e.td,{children:"Limited"}),(0,t.jsx)(e.td,{children:"Comprehensive"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Plugins"})}),(0,t.jsx)(e.td,{children:"ROS-specific"}),(0,t.jsx)(e.td,{children:"Gazebo-native"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Use Case"})}),(0,t.jsx)(e.td,{children:"ROS robot models"}),(0,t.jsx)(e.td,{children:"Full simulations"})]})]})]}),"\n",(0,t.jsx)(e.h2,{id:"assessment",children:"Assessment"}),"\n",(0,t.jsx)(e.h3,{id:"recall",children:"Recall"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"What is the difference between URDF and SDF formats?"}),"\n",(0,t.jsx)(e.li,{children:"What physics parameters affect simulation stability?"}),"\n",(0,t.jsx)(e.li,{children:"How do you bridge Gazebo with ROS 2?"}),"\n",(0,t.jsx)(e.li,{children:'What is the "reality gap" in robotics simulation?'}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"apply",children:"Apply"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Create a URDF model for a simple 2-DOF robot arm with proper inertial properties."}),"\n",(0,t.jsx)(e.li,{children:"Build a Gazebo world with stairs for testing humanoid climbing."}),"\n",(0,t.jsx)(e.li,{children:"Write a ROS 2 node that reads joint states from Gazebo and publishes them at 100 Hz."}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"analyze",children:"Analyze"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Why might a walking algorithm that works in Gazebo fail on a real robot?"}),"\n",(0,t.jsx)(e.li,{children:"Compare the trade-offs between simulation accuracy and speed."}),"\n",(0,t.jsx)(e.li,{children:"Design a testing strategy that uses simulation to reduce real-world testing time by 90%."}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(c,{...n})}):c(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>l,x:()=>r});var s=i(6540);const t={},o=s.createContext(t);function l(n){const e=s.useContext(o);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:l(n.components),s.createElement(o.Provider,{value:e},n.children)}}}]);