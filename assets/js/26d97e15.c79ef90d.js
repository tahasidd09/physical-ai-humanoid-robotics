"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[208],{7264:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"module4/week11-humanoid-dev","title":"Humanoid Kinematics and Dynamics","description":"Understanding humanoid robot kinematics, bipedal locomotion, and balance control","source":"@site/docs/module4/week11-humanoid-dev.md","sourceDirName":"module4","slug":"/module4/week11-humanoid-dev","permalink":"/physical-ai-and-humanoid-robotics/docs/module4/week11-humanoid-dev","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"Humanoid Kinematics and Dynamics","description":"Understanding humanoid robot kinematics, bipedal locomotion, and balance control","keywords":["humanoid","kinematics","dynamics","bipedal","locomotion","balance"]},"sidebar":"tutorialSidebar","previous":{"title":"Module 4: Vision-Language-Action","permalink":"/physical-ai-and-humanoid-robotics/docs/category/module-4-vision-language-action"},"next":{"title":"Manipulation and Human-Robot Interaction","permalink":"/physical-ai-and-humanoid-robotics/docs/module4/week12-humanoid-dev-2"}}');var o=t(4848),a=t(8453);const s={sidebar_position:1,title:"Humanoid Kinematics and Dynamics",description:"Understanding humanoid robot kinematics, bipedal locomotion, and balance control",keywords:["humanoid","kinematics","dynamics","bipedal","locomotion","balance"]},r="Humanoid Kinematics and Dynamics",l={},c=[{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"The Physics (Why)",id:"the-physics-why",level:2},{value:"The Analogy (Mental Model)",id:"the-analogy-mental-model",level:2},{value:"The Visualization (Kinematic Chain)",id:"the-visualization-kinematic-chain",level:2},{value:"The Code (Implementation)",id:"the-code-implementation",level:2},{value:"Forward Kinematics",id:"forward-kinematics",level:3},{value:"Inverse Kinematics",id:"inverse-kinematics",level:3},{value:"Balance Control with ZMP",id:"balance-control-with-zmp",level:3},{value:"The Hardware Reality (Warning)",id:"the-hardware-reality-warning",level:2},{value:"Common Humanoid Platforms",id:"common-humanoid-platforms",level:3},{value:"Assessment",id:"assessment",level:2},{value:"Recall",id:"recall",level:3},{value:"Apply",id:"apply",level:3},{value:"Analyze",id:"analyze",level:3}];function d(n){const e={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"humanoid-kinematics-and-dynamics",children:"Humanoid Kinematics and Dynamics"})}),"\n",(0,o.jsx)(e.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,o.jsx)(e.p,{children:"By the end of this chapter, you should be able to:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Understand forward and inverse kinematics for humanoid robots"}),"\n",(0,o.jsx)(e.li,{children:"Explain the challenges of bipedal locomotion"}),"\n",(0,o.jsx)(e.li,{children:"Implement basic balance control using the Zero Moment Point (ZMP)"}),"\n",(0,o.jsx)(e.li,{children:"Design kinematic chains for humanoid limbs"}),"\n",(0,o.jsx)(e.li,{children:"Calculate joint trajectories for walking gaits"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"the-physics-why",children:"The Physics (Why)"}),"\n",(0,o.jsx)(e.p,{children:"Humanoid robots are among the most complex mechanical systems ever built. A typical humanoid has 20-40 degrees of freedom (DOF), each requiring precise coordination."}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Kinematics"}),' answers: "Given joint angles, where is the end effector?"\n',(0,o.jsx)(e.strong,{children:"Inverse Kinematics"}),' answers: "Given a desired end effector position, what joint angles achieve it?"\n',(0,o.jsx)(e.strong,{children:"Dynamics"}),' answers: "What forces and torques are needed to achieve desired motion?"']}),"\n",(0,o.jsx)(e.p,{children:"For bipedal robots, the challenge is even greater:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Underactuation"}),": The robot can fall\u2014gravity is always acting"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Contact switching"}),": Support alternates between feet"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Balance"}),": Center of mass must stay over the support polygon"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Compliance"}),": Joints must absorb impacts during walking"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"the-analogy-mental-model",children:"The Analogy (Mental Model)"}),"\n",(0,o.jsxs)(e.p,{children:["Think of a humanoid robot like a ",(0,o.jsx)(e.strong,{children:"marionette puppet"}),":"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Strings"})," = Joint actuators (motors)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Wooden parts"})," = Rigid links (limbs)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Puppeteer"})," = Control system"]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"But unlike a puppet, a humanoid must:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Balance itself"})," (no strings from above)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"React to disturbances"})," (someone bumps into it)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Plan its own movements"})," (no puppeteer)"]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"The control system must be both the puppeteer AND the puppet's brain."}),"\n",(0,o.jsx)(e.h2,{id:"the-visualization-kinematic-chain",children:"The Visualization (Kinematic Chain)"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-mermaid",children:'graph TB\n    subgraph "Humanoid Kinematic Tree"\n        A[Base/Pelvis] --\x3e B[Left Hip]\n        A --\x3e C[Right Hip]\n        A --\x3e D[Torso]\n        \n        B --\x3e E[Left Knee]\n        E --\x3e F[Left Ankle]\n        F --\x3e G[Left Foot]\n        \n        C --\x3e H[Right Knee]\n        H --\x3e I[Right Ankle]\n        I --\x3e J[Right Foot]\n        \n        D --\x3e K[Left Shoulder]\n        D --\x3e L[Right Shoulder]\n        D --\x3e M[Neck]\n        \n        K --\x3e N[Left Elbow]\n        N --\x3e O[Left Wrist]\n        \n        L --\x3e P[Right Elbow]\n        P --\x3e Q[Right Wrist]\n        \n        M --\x3e R[Head]\n    end\n'})}),"\n",(0,o.jsx)(e.h2,{id:"the-code-implementation",children:"The Code (Implementation)"}),"\n",(0,o.jsx)(e.h3,{id:"forward-kinematics",children:"Forward Kinematics"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""\nforward_kinematics.py - Calculate end effector position from joint angles.\n"""\n\nimport numpy as np\nfrom dataclasses import dataclass\nfrom typing import List, Tuple\n\n\n@dataclass\nclass DHParameters:\n    """Denavit-Hartenberg parameters for a joint."""\n    theta: float  # Joint angle (radians)\n    d: float      # Link offset\n    a: float      # Link length\n    alpha: float  # Link twist\n\n\ndef dh_transform(params: DHParameters) -> np.ndarray:\n    """\n    Compute transformation matrix from DH parameters.\n    \n    Args:\n        params: DH parameters for the joint\n        \n    Returns:\n        4x4 homogeneous transformation matrix\n    """\n    ct = np.cos(params.theta)\n    st = np.sin(params.theta)\n    ca = np.cos(params.alpha)\n    sa = np.sin(params.alpha)\n    \n    return np.array([\n        [ct, -st * ca,  st * sa, params.a * ct],\n        [st,  ct * ca, -ct * sa, params.a * st],\n        [0,   sa,       ca,      params.d],\n        [0,   0,        0,       1]\n    ])\n\n\nclass HumanoidLeg:\n    """6-DOF humanoid leg kinematics."""\n    \n    def __init__(self, thigh_length: float = 0.4, shin_length: float = 0.4):\n        self.thigh_length = thigh_length\n        self.shin_length = shin_length\n        \n        # Joint limits (radians)\n        self.joint_limits = {\n            \'hip_yaw\': (-0.5, 0.5),\n            \'hip_roll\': (-0.5, 0.5),\n            \'hip_pitch\': (-1.5, 0.5),\n            \'knee_pitch\': (0.0, 2.5),\n            \'ankle_pitch\': (-0.8, 0.8),\n            \'ankle_roll\': (-0.3, 0.3),\n        }\n    \n    def forward_kinematics(self, joint_angles: List[float]) -> np.ndarray:\n        """\n        Calculate foot position from joint angles.\n        \n        Args:\n            joint_angles: [hip_yaw, hip_roll, hip_pitch, knee, ankle_pitch, ankle_roll]\n            \n        Returns:\n            4x4 transformation matrix from hip to foot\n        """\n        if len(joint_angles) != 6:\n            raise ValueError("Expected 6 joint angles")\n        \n        # DH parameters for each joint\n        dh_params = [\n            DHParameters(joint_angles[0], 0, 0, np.pi/2),      # Hip yaw\n            DHParameters(joint_angles[1], 0, 0, np.pi/2),      # Hip roll\n            DHParameters(joint_angles[2], 0, self.thigh_length, 0),  # Hip pitch\n            DHParameters(joint_angles[3], 0, self.shin_length, 0),   # Knee\n            DHParameters(joint_angles[4], 0, 0, np.pi/2),      # Ankle pitch\n            DHParameters(joint_angles[5], 0, 0, 0),            # Ankle roll\n        ]\n        \n        # Chain transformations\n        T = np.eye(4)\n        for params in dh_params:\n            T = T @ dh_transform(params)\n        \n        return T\n    \n    def get_foot_position(self, joint_angles: List[float]) -> Tuple[float, float, float]:\n        """Get foot position in hip frame."""\n        T = self.forward_kinematics(joint_angles)\n        return (T[0, 3], T[1, 3], T[2, 3])\n\n\n# Example usage\nif __name__ == "__main__":\n    leg = HumanoidLeg(thigh_length=0.4, shin_length=0.4)\n    \n    # Standing pose (leg straight down)\n    standing = [0, 0, 0, 0, 0, 0]\n    pos = leg.get_foot_position(standing)\n    print(f"Standing foot position: {pos}")\n    \n    # Bent knee pose\n    bent = [0, 0, -0.5, 1.0, -0.5, 0]\n    pos = leg.get_foot_position(bent)\n    print(f"Bent knee foot position: {pos}")\n'})}),"\n",(0,o.jsx)(e.h3,{id:"inverse-kinematics",children:"Inverse Kinematics"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""\ninverse_kinematics.py - Calculate joint angles for desired foot position.\n"""\n\nimport numpy as np\nfrom typing import List, Optional, Tuple\nfrom scipy.optimize import minimize\n\n\nclass InverseKinematics:\n    """Numerical inverse kinematics solver."""\n    \n    def __init__(self, leg: \'HumanoidLeg\'):\n        self.leg = leg\n    \n    def solve(\n        self,\n        target_position: Tuple[float, float, float],\n        initial_guess: Optional[List[float]] = None\n    ) -> Optional[List[float]]:\n        """\n        Solve IK for target foot position.\n        \n        Args:\n            target_position: Desired (x, y, z) foot position\n            initial_guess: Starting joint angles for optimization\n            \n        Returns:\n            Joint angles that achieve target, or None if no solution\n        """\n        if initial_guess is None:\n            initial_guess = [0.0] * 6\n        \n        target = np.array(target_position)\n        \n        def cost_function(angles):\n            """Cost = distance from target."""\n            current = np.array(self.leg.get_foot_position(angles))\n            return np.sum((current - target) ** 2)\n        \n        # Joint limits as bounds\n        bounds = [\n            self.leg.joint_limits[\'hip_yaw\'],\n            self.leg.joint_limits[\'hip_roll\'],\n            self.leg.joint_limits[\'hip_pitch\'],\n            self.leg.joint_limits[\'knee_pitch\'],\n            self.leg.joint_limits[\'ankle_pitch\'],\n            self.leg.joint_limits[\'ankle_roll\'],\n        ]\n        \n        result = minimize(\n            cost_function,\n            initial_guess,\n            method=\'SLSQP\',\n            bounds=bounds,\n            options={\'ftol\': 1e-8}\n        )\n        \n        if result.success and result.fun < 1e-6:\n            return list(result.x)\n        return None\n\n\nclass WalkingGaitGenerator:\n    """Generate walking gait trajectories."""\n    \n    def __init__(self, step_length: float = 0.2, step_height: float = 0.05):\n        self.step_length = step_length\n        self.step_height = step_height\n        self.step_duration = 0.5  # seconds\n    \n    def generate_foot_trajectory(\n        self,\n        start_pos: Tuple[float, float, float],\n        end_pos: Tuple[float, float, float],\n        num_points: int = 50\n    ) -> List[Tuple[float, float, float]]:\n        """\n        Generate smooth foot trajectory for a step.\n        \n        Uses a cycloid curve for natural foot motion.\n        """\n        trajectory = []\n        \n        for i in range(num_points):\n            t = i / (num_points - 1)  # 0 to 1\n            \n            # X: linear interpolation\n            x = start_pos[0] + t * (end_pos[0] - start_pos[0])\n            \n            # Y: linear interpolation\n            y = start_pos[1] + t * (end_pos[1] - start_pos[1])\n            \n            # Z: parabolic arc for foot clearance\n            z = start_pos[2] + 4 * self.step_height * t * (1 - t)\n            \n            trajectory.append((x, y, z))\n        \n        return trajectory\n'})}),"\n",(0,o.jsx)(e.h3,{id:"balance-control-with-zmp",children:"Balance Control with ZMP"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""\nbalance_control.py - Zero Moment Point (ZMP) based balance control.\n"""\n\nimport numpy as np\nfrom dataclasses import dataclass\nfrom typing import Tuple\n\n\n@dataclass\nclass RobotState:\n    """Current state of the humanoid robot."""\n    com_position: np.ndarray      # Center of mass position\n    com_velocity: np.ndarray      # Center of mass velocity\n    left_foot_pos: np.ndarray     # Left foot position\n    right_foot_pos: np.ndarray    # Right foot position\n    support_foot: str             # \'left\', \'right\', or \'double\'\n\n\nclass ZMPController:\n    """\n    Zero Moment Point controller for balance.\n    \n    ZMP is the point where the sum of horizontal inertial and \n    gravity forces equals zero. For stable walking, ZMP must \n    stay within the support polygon.\n    """\n    \n    def __init__(self, robot_mass: float = 50.0, com_height: float = 0.9):\n        self.mass = robot_mass\n        self.com_height = com_height\n        self.gravity = 9.81\n        \n        # Control gains\n        self.kp = 100.0  # Position gain\n        self.kd = 20.0   # Damping gain\n    \n    def calculate_zmp(self, state: RobotState) -> np.ndarray:\n        """\n        Calculate current ZMP from robot state.\n        \n        ZMP_x = CoM_x - (CoM_z / g) * CoM_ddot_x\n        """\n        # Simplified: assume constant height, estimate acceleration from velocity\n        # In practice, use IMU data for acceleration\n        \n        zmp = np.array([\n            state.com_position[0],\n            state.com_position[1]\n        ])\n        \n        return zmp\n    \n    def get_support_polygon(self, state: RobotState) -> np.ndarray:\n        """Get vertices of current support polygon."""\n        foot_size = 0.1  # Half foot length\n        \n        if state.support_foot == \'left\':\n            center = state.left_foot_pos[:2]\n        elif state.support_foot == \'right\':\n            center = state.right_foot_pos[:2]\n        else:  # double support\n            # Convex hull of both feet\n            left = state.left_foot_pos[:2]\n            right = state.right_foot_pos[:2]\n            return np.array([\n                left + np.array([-foot_size, -foot_size/2]),\n                left + np.array([foot_size, -foot_size/2]),\n                right + np.array([foot_size, foot_size/2]),\n                right + np.array([-foot_size, foot_size/2]),\n            ])\n        \n        return np.array([\n            center + np.array([-foot_size, -foot_size/2]),\n            center + np.array([foot_size, -foot_size/2]),\n            center + np.array([foot_size, foot_size/2]),\n            center + np.array([-foot_size, foot_size/2]),\n        ])\n    \n    def is_stable(self, state: RobotState) -> bool:\n        """Check if ZMP is within support polygon."""\n        zmp = self.calculate_zmp(state)\n        polygon = self.get_support_polygon(state)\n        \n        # Point-in-polygon test (simplified)\n        # In practice, use proper convex hull containment\n        center = np.mean(polygon, axis=0)\n        max_dist = np.max(np.linalg.norm(polygon - center, axis=1))\n        \n        return np.linalg.norm(zmp - center) < max_dist * 0.8\n    \n    def compute_balance_torque(\n        self,\n        state: RobotState,\n        desired_zmp: np.ndarray\n    ) -> Tuple[float, float]:\n        """\n        Compute ankle torques to maintain balance.\n        \n        Returns:\n            (pitch_torque, roll_torque) for the support ankle\n        """\n        current_zmp = self.calculate_zmp(state)\n        zmp_error = desired_zmp - current_zmp\n        \n        # PD control on ZMP error\n        # Ankle pitch controls forward/backward (x)\n        # Ankle roll controls left/right (y)\n        \n        pitch_torque = self.kp * zmp_error[0]\n        roll_torque = self.kp * zmp_error[1]\n        \n        # Limit torques\n        max_torque = 50.0  # Nm\n        pitch_torque = np.clip(pitch_torque, -max_torque, max_torque)\n        roll_torque = np.clip(roll_torque, -max_torque, max_torque)\n        \n        return (pitch_torque, roll_torque)\n\n\n# Example usage\nif __name__ == "__main__":\n    controller = ZMPController()\n    \n    state = RobotState(\n        com_position=np.array([0.0, 0.0, 0.9]),\n        com_velocity=np.array([0.0, 0.0, 0.0]),\n        left_foot_pos=np.array([-0.1, 0.0, 0.0]),\n        right_foot_pos=np.array([0.1, 0.0, 0.0]),\n        support_foot=\'double\'\n    )\n    \n    print(f"ZMP: {controller.calculate_zmp(state)}")\n    print(f"Stable: {controller.is_stable(state)}")\n'})}),"\n",(0,o.jsx)(e.h2,{id:"the-hardware-reality-warning",children:"The Hardware Reality (Warning)"}),"\n",(0,o.jsxs)(e.admonition,{title:"Falling is Expensive",type:"danger",children:[(0,o.jsx)(e.p,{children:"Humanoid robots can be severely damaged by falls:"}),(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Motors"}),": Impact forces can strip gears"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Sensors"}),": IMUs and cameras are fragile"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Structure"}),": Carbon fiber cracks, aluminum bends"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Cost"}),": A single fall can cause $1,000-$10,000 in damage"]}),"\n"]}),(0,o.jsx)(e.p,{children:"Always test in simulation first, and use safety harnesses for real robot experiments."})]}),"\n",(0,o.jsxs)(e.admonition,{title:"Computational Requirements",type:"warning",children:[(0,o.jsx)(e.p,{children:"Real-time balance control requires:"}),(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Control loop"}),": 1 kHz (1ms cycle time)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"IK solver"}),": <5ms per solution"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"State estimation"}),": <2ms latency"]}),"\n"]}),(0,o.jsx)(e.p,{children:"Jetson Orin can handle this, but careful optimization is required."})]}),"\n",(0,o.jsx)(e.h3,{id:"common-humanoid-platforms",children:"Common Humanoid Platforms"}),"\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"Robot"}),(0,o.jsx)(e.th,{children:"DOF"}),(0,o.jsx)(e.th,{children:"Height"}),(0,o.jsx)(e.th,{children:"Weight"}),(0,o.jsx)(e.th,{children:"Cost"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"Unitree H1"}),(0,o.jsx)(e.td,{children:"19"}),(0,o.jsx)(e.td,{children:"1.8m"}),(0,o.jsx)(e.td,{children:"47kg"}),(0,o.jsx)(e.td,{children:"~$90,000"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"Unitree G1"}),(0,o.jsx)(e.td,{children:"23"}),(0,o.jsx)(e.td,{children:"1.3m"}),(0,o.jsx)(e.td,{children:"35kg"}),(0,o.jsx)(e.td,{children:"~$16,000"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"Boston Dynamics Atlas"}),(0,o.jsx)(e.td,{children:"28"}),(0,o.jsx)(e.td,{children:"1.5m"}),(0,o.jsx)(e.td,{children:"89kg"}),(0,o.jsx)(e.td,{children:"Not for sale"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"Agility Digit"}),(0,o.jsx)(e.td,{children:"16"}),(0,o.jsx)(e.td,{children:"1.6m"}),(0,o.jsx)(e.td,{children:"42kg"}),(0,o.jsx)(e.td,{children:"~$250,000"})]})]})]}),"\n",(0,o.jsx)(e.h2,{id:"assessment",children:"Assessment"}),"\n",(0,o.jsx)(e.h3,{id:"recall",children:"Recall"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"What is the difference between forward and inverse kinematics?"}),"\n",(0,o.jsx)(e.li,{children:"What is the Zero Moment Point (ZMP) and why is it important for balance?"}),"\n",(0,o.jsx)(e.li,{children:"How many degrees of freedom does a typical humanoid leg have?"}),"\n",(0,o.jsx)(e.li,{children:"What is the support polygon and how does it relate to stability?"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"apply",children:"Apply"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Implement forward kinematics for a 3-DOF robot arm (shoulder, elbow, wrist)."}),"\n",(0,o.jsx)(e.li,{children:"Write a function that checks if a given ZMP is within a rectangular support polygon."}),"\n",(0,o.jsx)(e.li,{children:"Generate a walking gait trajectory for 5 steps, alternating between left and right feet."}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"analyze",children:"Analyze"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Why is inverse kinematics more computationally expensive than forward kinematics?"}),"\n",(0,o.jsx)(e.li,{children:"Compare the stability challenges of bipedal vs. quadruped robots."}),"\n",(0,o.jsx)(e.li,{children:"Design a recovery strategy for when a humanoid robot detects it is about to fall."}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>s,x:()=>r});var i=t(6540);const o={},a=i.createContext(o);function s(n){const e=i.useContext(a);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:s(n.components),i.createElement(a.Provider,{value:e},n.children)}}}]);