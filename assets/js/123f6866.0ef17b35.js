"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[315],{7463:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"module4/week12-humanoid-dev-2","title":"Manipulation and Human-Robot Interaction","description":"Humanoid manipulation, grasping, and designing natural human-robot interaction","source":"@site/docs/module4/week12-humanoid-dev-2.md","sourceDirName":"module4","slug":"/module4/week12-humanoid-dev-2","permalink":"/physical-ai-and-humanoid-robotics/docs/module4/week12-humanoid-dev-2","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"Manipulation and Human-Robot Interaction","description":"Humanoid manipulation, grasping, and designing natural human-robot interaction","keywords":["manipulation","grasping","human-robot-interaction","hri","gripper","dexterous"]},"sidebar":"tutorialSidebar","previous":{"title":"Humanoid Kinematics and Dynamics","permalink":"/physical-ai-and-humanoid-robotics/docs/module4/week11-humanoid-dev"},"next":{"title":"Conversational Robotics & VLA Models","permalink":"/physical-ai-and-humanoid-robotics/docs/module4/week13-conversational-robotics"}}');var t=i(4848),o=i(8453);const r={sidebar_position:2,title:"Manipulation and Human-Robot Interaction",description:"Humanoid manipulation, grasping, and designing natural human-robot interaction",keywords:["manipulation","grasping","human-robot-interaction","hri","gripper","dexterous"]},a="Manipulation and Human-Robot Interaction",l={},c=[{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"The Physics (Why)",id:"the-physics-why",level:2},{value:"The Analogy (Mental Model)",id:"the-analogy-mental-model",level:2},{value:"The Visualization (Manipulation Pipeline)",id:"the-visualization-manipulation-pipeline",level:2},{value:"The Code (Implementation)",id:"the-code-implementation",level:2},{value:"Grasp Planning",id:"grasp-planning",level:3},{value:"Force Control for Compliant Manipulation",id:"force-control-for-compliant-manipulation",level:3},{value:"ROS 2 Manipulation Node",id:"ros-2-manipulation-node",level:3},{value:"The Hardware Reality (Warning)",id:"the-hardware-reality-warning",level:2},{value:"Assessment",id:"assessment",level:2},{value:"Recall",id:"recall",level:3},{value:"Apply",id:"apply",level:3},{value:"Analyze",id:"analyze",level:3}];function d(n){const e={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"manipulation-and-human-robot-interaction",children:"Manipulation and Human-Robot Interaction"})}),"\n",(0,t.jsx)(e.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,t.jsx)(e.p,{children:"By the end of this chapter, you should be able to:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Understand grasp planning and manipulation strategies"}),"\n",(0,t.jsx)(e.li,{children:"Implement basic pick-and-place operations"}),"\n",(0,t.jsx)(e.li,{children:"Design safe human-robot interaction systems"}),"\n",(0,t.jsx)(e.li,{children:"Use force control for compliant manipulation"}),"\n",(0,t.jsx)(e.li,{children:"Recognize the challenges of dexterous manipulation"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"the-physics-why",children:"The Physics (Why)"}),"\n",(0,t.jsxs)(e.p,{children:["Manipulation is fundamentally about ",(0,t.jsx)(e.strong,{children:"controlling contact forces"}),". When a robot grasps an object:"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Normal forces"})," prevent the object from falling through the gripper"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Friction forces"})," prevent the object from slipping"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Torques"})," control object orientation"]}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:["The challenge is that contact is ",(0,t.jsx)(e.strong,{children:"discontinuous"}),"\u2014forces change abruptly when contact is made or broken. This makes manipulation much harder than free-space motion."]}),"\n",(0,t.jsx)(e.p,{children:"For human-robot interaction, safety requires:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Force limiting"}),": Never apply dangerous forces to humans"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Compliance"}),": Yield to unexpected contacts"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Predictability"}),": Humans must understand robot intentions"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"the-analogy-mental-model",children:"The Analogy (Mental Model)"}),"\n",(0,t.jsxs)(e.p,{children:["Think of robot manipulation like ",(0,t.jsx)(e.strong,{children:"learning to use chopsticks"}),":"]}),"\n",(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:"Chopstick Challenge"}),(0,t.jsx)(e.th,{children:"Robot Equivalent"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Coordinating two sticks"}),(0,t.jsx)(e.td,{children:"Coordinating multiple fingers"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Feeling food texture"}),(0,t.jsx)(e.td,{children:"Force/tactile sensing"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Adjusting grip pressure"}),(0,t.jsx)(e.td,{children:"Force control"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Not dropping food"}),(0,t.jsx)(e.td,{children:"Grasp stability"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Not crushing soft food"}),(0,t.jsx)(e.td,{children:"Compliance control"})]})]})]}),"\n",(0,t.jsx)(e.p,{children:"Just as chopstick mastery requires years of practice, dexterous robot manipulation remains an open research problem."}),"\n",(0,t.jsx)(e.h2,{id:"the-visualization-manipulation-pipeline",children:"The Visualization (Manipulation Pipeline)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-mermaid",children:'graph TB\n    subgraph "Perception"\n        A[RGB-D Camera] --\x3e B[Object Detection]\n        B --\x3e C[Pose Estimation]\n        C --\x3e D[Grasp Planning]\n    end\n    \n    subgraph "Planning"\n        D --\x3e E[Approach Path]\n        E --\x3e F[Grasp Execution]\n        F --\x3e G[Lift & Transport]\n        G --\x3e H[Place]\n    end\n    \n    subgraph "Control"\n        F --\x3e I[Force Control]\n        I --\x3e J[Gripper Commands]\n        K[Force Sensor] --\x3e I\n    end\n    \n    subgraph "Safety"\n        L[Collision Detection] --\x3e M[Emergency Stop]\n        N[Human Detection] --\x3e O[Speed Limiting]\n    end\n'})}),"\n",(0,t.jsx)(e.h2,{id:"the-code-implementation",children:"The Code (Implementation)"}),"\n",(0,t.jsx)(e.h3,{id:"grasp-planning",children:"Grasp Planning"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""\ngrasp_planning.py - Plan grasps for object manipulation.\n"""\n\nimport numpy as np\nfrom dataclasses import dataclass\nfrom typing import List, Tuple, Optional\n\n\n@dataclass\nclass GraspPose:\n    """Represents a candidate grasp."""\n    position: np.ndarray      # Gripper position\n    orientation: np.ndarray   # Quaternion\n    width: float              # Gripper opening width\n    quality: float            # Grasp quality score\n\n\n@dataclass\nclass ObjectInfo:\n    """Information about object to grasp."""\n    position: np.ndarray\n    dimensions: np.ndarray    # (length, width, height)\n    mass: float\n    friction_coef: float\n\n\nclass GraspPlanner:\n    """Plan stable grasps for objects."""\n    \n    def __init__(self, gripper_max_width: float = 0.1):\n        self.gripper_max_width = gripper_max_width\n        self.min_friction = 0.3\n    \n    def plan_grasps(\n        self,\n        obj: ObjectInfo,\n        num_candidates: int = 10\n    ) -> List[GraspPose]:\n        """\n        Generate candidate grasps for an object.\n        \n        Uses antipodal grasp heuristic: grasp along object\'s\n        shortest dimension for stability.\n        """\n        candidates = []\n        \n        # Find graspable dimension (must fit in gripper)\n        dims = obj.dimensions\n        graspable_dims = [i for i, d in enumerate(dims) if d < self.gripper_max_width]\n        \n        if not graspable_dims:\n            return []  # Object too large\n        \n        # Generate grasps along each graspable axis\n        for dim_idx in graspable_dims:\n            for angle in np.linspace(0, np.pi, num_candidates // len(graspable_dims)):\n                grasp = self.generate_grasp(obj, dim_idx, angle)\n                if grasp:\n                    candidates.append(grasp)\n        \n        # Sort by quality\n        candidates.sort(key=lambda g: g.quality, reverse=True)\n        \n        return candidates\n    \n    def generate_grasp(\n        self,\n        obj: ObjectInfo,\n        grasp_axis: int,\n        rotation: float\n    ) -> Optional[GraspPose]:\n        """Generate a single grasp candidate."""\n        # Position at object center\n        position = obj.position.copy()\n        \n        # Orientation based on grasp axis\n        # (simplified - real implementation uses proper rotation matrices)\n        orientation = np.array([0, 0, np.sin(rotation/2), np.cos(rotation/2)])\n        \n        # Width slightly larger than object dimension\n        width = obj.dimensions[grasp_axis] + 0.01\n        \n        # Quality based on friction and stability\n        quality = self.evaluate_grasp_quality(obj, grasp_axis)\n        \n        return GraspPose(\n            position=position,\n            orientation=orientation,\n            width=width,\n            quality=quality\n        )\n    \n    def evaluate_grasp_quality(self, obj: ObjectInfo, grasp_axis: int) -> float:\n        """\n        Evaluate grasp quality using force closure analysis.\n        \n        Higher quality = more stable grasp.\n        """\n        # Simplified quality metric\n        # Real implementation would use GraspIt! or similar\n        \n        # Prefer grasping along shortest dimension\n        dims = obj.dimensions\n        dim_score = 1.0 - (dims[grasp_axis] / max(dims))\n        \n        # Friction score\n        friction_score = min(1.0, obj.friction_coef / self.min_friction)\n        \n        # Mass penalty (heavier objects harder to grasp)\n        mass_score = 1.0 / (1.0 + obj.mass / 5.0)\n        \n        return 0.4 * dim_score + 0.4 * friction_score + 0.2 * mass_score\n\n\nclass PickAndPlace:\n    """Execute pick and place operations."""\n    \n    def __init__(self, arm_controller, gripper_controller):\n        self.arm = arm_controller\n        self.gripper = gripper_controller\n        self.planner = GraspPlanner()\n    \n    def pick(self, obj: ObjectInfo) -> bool:\n        """Pick up an object."""\n        # Plan grasp\n        grasps = self.planner.plan_grasps(obj)\n        if not grasps:\n            return False\n        \n        best_grasp = grasps[0]\n        \n        # Open gripper\n        self.gripper.open(best_grasp.width + 0.02)\n        \n        # Move to pre-grasp position (above object)\n        pre_grasp = best_grasp.position.copy()\n        pre_grasp[2] += 0.1  # 10cm above\n        self.arm.move_to(pre_grasp, best_grasp.orientation)\n        \n        # Move to grasp position\n        self.arm.move_to(best_grasp.position, best_grasp.orientation)\n        \n        # Close gripper\n        success = self.gripper.close(force_limit=20.0)\n        \n        if success:\n            # Lift object\n            lift_pos = best_grasp.position.copy()\n            lift_pos[2] += 0.15\n            self.arm.move_to(lift_pos, best_grasp.orientation)\n        \n        return success\n    \n    def place(self, target_position: np.ndarray) -> bool:\n        """Place held object at target position."""\n        # Move above target\n        above_target = target_position.copy()\n        above_target[2] += 0.1\n        self.arm.move_to(above_target)\n        \n        # Lower to target\n        self.arm.move_to(target_position)\n        \n        # Open gripper\n        self.gripper.open()\n        \n        # Retreat\n        self.arm.move_to(above_target)\n        \n        return True\n'})}),"\n",(0,t.jsx)(e.h3,{id:"force-control-for-compliant-manipulation",children:"Force Control for Compliant Manipulation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""\nforce_control.py - Compliant manipulation with force feedback.\n"""\n\nimport numpy as np\nfrom dataclasses import dataclass\nfrom typing import Tuple\n\n\n@dataclass\nclass ForceReading:\n    """6-axis force/torque reading."""\n    force: np.ndarray   # (fx, fy, fz)\n    torque: np.ndarray  # (tx, ty, tz)\n\n\nclass ImpedanceController:\n    """\n    Impedance control for compliant manipulation.\n    \n    Makes the robot behave like a mass-spring-damper system,\n    allowing safe interaction with environment and humans.\n    """\n    \n    def __init__(\n        self,\n        stiffness: np.ndarray = None,\n        damping: np.ndarray = None,\n        mass: np.ndarray = None\n    ):\n        # Default parameters (can be tuned per task)\n        self.K = stiffness if stiffness is not None else np.array([500, 500, 500])\n        self.D = damping if damping is not None else np.array([50, 50, 50])\n        self.M = mass if mass is not None else np.array([1, 1, 1])\n        \n        # State\n        self.position = np.zeros(3)\n        self.velocity = np.zeros(3)\n    \n    def compute_command(\n        self,\n        desired_position: np.ndarray,\n        current_position: np.ndarray,\n        current_velocity: np.ndarray,\n        external_force: np.ndarray\n    ) -> np.ndarray:\n        """\n        Compute position command with impedance behavior.\n        \n        F = M*a + D*v + K*x\n        \n        The robot will yield to external forces while trying\n        to reach the desired position.\n        """\n        # Position error\n        pos_error = desired_position - current_position\n        \n        # Impedance equation: solve for acceleration\n        # M*a = F_ext - D*v - K*x\n        acceleration = (\n            external_force - \n            self.D * current_velocity - \n            self.K * pos_error\n        ) / self.M\n        \n        # Integrate to get velocity and position\n        dt = 0.01  # 100 Hz control\n        new_velocity = current_velocity + acceleration * dt\n        new_position = current_position + new_velocity * dt\n        \n        return new_position\n    \n    def set_stiffness(self, stiffness: np.ndarray):\n        """Adjust stiffness (higher = stiffer, less compliant)."""\n        self.K = np.clip(stiffness, 10, 2000)\n    \n    def set_compliant_mode(self):\n        """Set low stiffness for safe human interaction."""\n        self.K = np.array([100, 100, 100])\n        self.D = np.array([20, 20, 20])\n    \n    def set_stiff_mode(self):\n        """Set high stiffness for precise positioning."""\n        self.K = np.array([1000, 1000, 1000])\n        self.D = np.array([100, 100, 100])\n\n\nclass SafeHumanInteraction:\n    """Safety system for human-robot interaction."""\n    \n    def __init__(self):\n        # Safety limits\n        self.max_force = 50.0      # Newtons\n        self.max_speed = 0.5       # m/s near humans\n        self.min_distance = 0.3   # meters\n        \n        # State\n        self.human_detected = False\n        self.human_distance = float(\'inf\')\n    \n    def update_human_detection(self, distance: float):\n        """Update human proximity information."""\n        self.human_distance = distance\n        self.human_detected = distance < 2.0\n    \n    def get_safe_speed_limit(self) -> float:\n        """Get speed limit based on human proximity."""\n        if not self.human_detected:\n            return 1.0  # Full speed\n        \n        if self.human_distance < self.min_distance:\n            return 0.0  # Stop\n        \n        # Linear scaling between min_distance and 2m\n        scale = (self.human_distance - self.min_distance) / (2.0 - self.min_distance)\n        return self.max_speed * scale\n    \n    def check_force_limit(self, force: ForceReading) -> Tuple[bool, str]:\n        """Check if force exceeds safety limits."""\n        force_magnitude = np.linalg.norm(force.force)\n        \n        if force_magnitude > self.max_force:\n            return False, f"Force limit exceeded: {force_magnitude:.1f}N > {self.max_force}N"\n        \n        return True, "OK"\n    \n    def should_emergency_stop(self, force: ForceReading) -> bool:\n        """Determine if emergency stop is needed."""\n        force_magnitude = np.linalg.norm(force.force)\n        \n        # Emergency stop if force is way over limit\n        if force_magnitude > self.max_force * 1.5:\n            return True\n        \n        # Emergency stop if human too close\n        if self.human_distance < 0.1:\n            return True\n        \n        return False\n'})}),"\n",(0,t.jsx)(e.h3,{id:"ros-2-manipulation-node",children:"ROS 2 Manipulation Node"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""\nmanipulation_node.py - ROS 2 node for manipulation tasks.\n"""\n\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import PoseStamped, WrenchStamped\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import Bool\nimport numpy as np\n\n\nclass ManipulationNode(Node):\n    """ROS 2 node for humanoid manipulation."""\n    \n    def __init__(self):\n        super().__init__(\'manipulation_node\')\n        \n        # Controllers\n        self.impedance = ImpedanceController()\n        self.safety = SafeHumanInteraction()\n        \n        # State\n        self.current_pose = None\n        self.current_force = None\n        self.target_pose = None\n        \n        # Subscribers\n        self.pose_sub = self.create_subscription(\n            PoseStamped, \'/arm/current_pose\', self.pose_callback, 10\n        )\n        self.force_sub = self.create_subscription(\n            WrenchStamped, \'/arm/force_torque\', self.force_callback, 10\n        )\n        self.target_sub = self.create_subscription(\n            PoseStamped, \'/arm/target_pose\', self.target_callback, 10\n        )\n        \n        # Publishers\n        self.cmd_pub = self.create_publisher(\n            PoseStamped, \'/arm/command_pose\', 10\n        )\n        self.stop_pub = self.create_publisher(\n            Bool, \'/emergency_stop\', 10\n        )\n        \n        # Control loop at 100 Hz\n        self.timer = self.create_timer(0.01, self.control_loop)\n        \n        self.get_logger().info(\'Manipulation node started\')\n    \n    def pose_callback(self, msg: PoseStamped):\n        """Update current end-effector pose."""\n        self.current_pose = np.array([\n            msg.pose.position.x,\n            msg.pose.position.y,\n            msg.pose.position.z\n        ])\n    \n    def force_callback(self, msg: WrenchStamped):\n        """Update force/torque reading."""\n        self.current_force = ForceReading(\n            force=np.array([\n                msg.wrench.force.x,\n                msg.wrench.force.y,\n                msg.wrench.force.z\n            ]),\n            torque=np.array([\n                msg.wrench.torque.x,\n                msg.wrench.torque.y,\n                msg.wrench.torque.z\n            ])\n        )\n    \n    def target_callback(self, msg: PoseStamped):\n        """Update target pose."""\n        self.target_pose = np.array([\n            msg.pose.position.x,\n            msg.pose.position.y,\n            msg.pose.position.z\n        ])\n    \n    def control_loop(self):\n        """Main control loop with safety checks."""\n        if self.current_pose is None or self.target_pose is None:\n            return\n        \n        # Safety checks\n        if self.current_force:\n            if self.safety.should_emergency_stop(self.current_force):\n                self.emergency_stop()\n                return\n            \n            safe, msg = self.safety.check_force_limit(self.current_force)\n            if not safe:\n                self.get_logger().warn(msg)\n                self.impedance.set_compliant_mode()\n        \n        # Compute command with impedance control\n        external_force = self.current_force.force if self.current_force else np.zeros(3)\n        \n        command_pos = self.impedance.compute_command(\n            desired_position=self.target_pose,\n            current_position=self.current_pose,\n            current_velocity=np.zeros(3),  # Would come from velocity estimation\n            external_force=external_force\n        )\n        \n        # Publish command\n        cmd_msg = PoseStamped()\n        cmd_msg.header.stamp = self.get_clock().now().to_msg()\n        cmd_msg.pose.position.x = command_pos[0]\n        cmd_msg.pose.position.y = command_pos[1]\n        cmd_msg.pose.position.z = command_pos[2]\n        \n        self.cmd_pub.publish(cmd_msg)\n    \n    def emergency_stop(self):\n        """Trigger emergency stop."""\n        self.get_logger().error(\'EMERGENCY STOP\')\n        stop_msg = Bool()\n        stop_msg.data = True\n        self.stop_pub.publish(stop_msg)\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = ManipulationNode()\n    rclpy.spin(node)\n    node.destroy_node()\n    rclpy.shutdown()\n\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,t.jsx)(e.h2,{id:"the-hardware-reality-warning",children:"The Hardware Reality (Warning)"}),"\n",(0,t.jsxs)(e.admonition,{title:"Human Safety is Paramount",type:"danger",children:[(0,t.jsx)(e.p,{children:"When robots interact with humans:"}),(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"ISO 10218"}),": Industrial robot safety standards"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"ISO/TS 15066"}),": Collaborative robot safety"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Force limits"}),": Max 150N transient, 65N quasi-static for human contact"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Speed limits"}),": Max 250mm/s in collaborative mode"]}),"\n"]}),(0,t.jsx)(e.p,{children:"Violating these limits can cause serious injury."})]}),"\n",(0,t.jsxs)(e.admonition,{title:"Gripper Selection",type:"warning",children:[(0,t.jsx)(e.p,{children:"Choose grippers based on task requirements:"}),(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:"Gripper Type"}),(0,t.jsx)(e.th,{children:"Payload"}),(0,t.jsx)(e.th,{children:"Dexterity"}),(0,t.jsx)(e.th,{children:"Cost"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Parallel jaw"}),(0,t.jsx)(e.td,{children:"High"}),(0,t.jsx)(e.td,{children:"Low"}),(0,t.jsx)(e.td,{children:"$500-2k"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Soft gripper"}),(0,t.jsx)(e.td,{children:"Medium"}),(0,t.jsx)(e.td,{children:"Medium"}),(0,t.jsx)(e.td,{children:"$1k-5k"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Dexterous hand"}),(0,t.jsx)(e.td,{children:"Low"}),(0,t.jsx)(e.td,{children:"High"}),(0,t.jsx)(e.td,{children:"$20k-100k"})]})]})]}),(0,t.jsx)(e.p,{children:"Most humanoid applications use parallel jaw grippers for reliability."})]}),"\n",(0,t.jsx)(e.h2,{id:"assessment",children:"Assessment"}),"\n",(0,t.jsx)(e.h3,{id:"recall",children:"Recall"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"What is impedance control and why is it important for manipulation?"}),"\n",(0,t.jsx)(e.li,{children:"What are the ISO safety standards for collaborative robots?"}),"\n",(0,t.jsx)(e.li,{children:"What is an antipodal grasp?"}),"\n",(0,t.jsx)(e.li,{children:"Why is force sensing important for manipulation?"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"apply",children:"Apply"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Implement a grasp planner for cylindrical objects (cups, bottles)."}),"\n",(0,t.jsx)(e.li,{children:"Write a safety monitor that limits robot speed based on human proximity."}),"\n",(0,t.jsx)(e.li,{children:"Design an impedance controller that becomes more compliant when force exceeds a threshold."}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"analyze",children:"Analyze"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Compare the trade-offs between position control and force control for manipulation."}),"\n",(0,t.jsx)(e.li,{children:"Why is dexterous manipulation with multi-fingered hands still an open research problem?"}),"\n",(0,t.jsx)(e.li,{children:"Design a human-robot handover protocol that is both safe and efficient."}),"\n"]})]})}function p(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>r,x:()=>a});var s=i(6540);const t={},o=s.createContext(t);function r(n){const e=s.useContext(o);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:r(n.components),s.createElement(o.Provider,{value:e},n.children)}}}]);